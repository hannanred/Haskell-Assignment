import System.IO  
import Control.Monad

-----------------------------------------------------------------------------------------------

--OUTPUT FILE NAME WITH THE NAME OF output.txt WILL BE GENERATED BY RUNNING THE Scanner FUNCTION

-- Not necessary to run the main function
main = do  
        putStrLn (show "Please Enter Name of the input cpp text file in the format name.txt or name.cpp")
        name <- getLine
        scanner name
        putStrLn (show "The file has been generated with the name of output.txt")
        

f :: String -> [String]
f = read


-- This is the scanner function, the argument is the file name
scanner name = do 
  x <- readFile name
  let singlewords = lines x
  let finale = dListConvertor (tupleGenerator (final singlewords))
  writeFile "output.txt" $ sentenceGrabber finale

----------------------------------------------------------------------------------------------------------

identifiers1 (x:xs) = if ((lengthOfWord (x:xs)) >= 2) then True else False
identifiers2 x = if (findInList listOfDigits x) == False then True else False
identifiers3 (x:xs) = if (findInList capitalLetters x) == True then True else identifiers3 xs
identifiers3 [] = False



digitsHeptal = "0123456"
digitsPrec = ".0123456"
checkInt (x:xs) checkIntBool = if checkIntBool /= False 
                                then  if (findInList digitsHeptal x) == True 
                                        then checkInt xs True  
                                        else checkInt xs False 
                                else False
checkInt [] True = True                                           
checkInt [] False = False


checkPrec (x:xs) checkPrecBool = if checkPrecBool /= False
                                    then if (findInList digitsPrec x) == True
                                        then checkPrec xs True
                                        else checkPrec xs False
                                    else False
checkPrec [] True = True
checkPrec [] False = False



identifiers (x:xs)= if [x] /= "\"" && [(lastNode (x:xs))] /="\"" && (identifiers1 (x:xs)) == True && (identifiers2 x) == True && (identifiers3 (x:xs)) == True then True else False

stringConstant (x:xs:xss) = if [x] == "\"" && [(lastNode (x:xs:xss))] == "\"" then True else False
stringConstant (x:[]) = False

--from previous assignment as helpers
listWithoutLast (x:xs) n = if (n-1) > 0
                                then x:listWithoutLast(xs) (n-1)
                                else []
lastNode node = node!!((lengthOfList node)-1)
secondLastNode node = node!!((lengthOfList node)-2)
lengthOfList (x:xs) = 1 + lengthOfList xs 
lengthOfList [] = 0
--from prev as helpers  

listWithoutFirstAndLast (x:xs:xss) = xs:(listWithoutLast xss (lengthOfList xss))

listOfDigits = "0123456789"
capitalLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
keywords = ["int","float","double","bool","void","while","for","if","else","char","array","struct","class","break","case","return","cout","cin","true","false","endl","string"]

delimeters2 = [",",";",":"]
delimeters = ",;:"
operators = "+-*/%<≤>≥===!=&&||[]()−−{}+<<>>"
operators2 = ["+", "-", "*", "/", "%", "<", "<=", ">", ">=", "=", "==", "!=", "&&", "||", "[", "]", "(",")", "−−", "{", "}", "++", "<<", ">>"]
lengthOfWord (x:xs) = 1 + lengthOfWord xs  --returns length of a list
lengthOfWord [] = 0 

lastElem (x:xs) = if xs == [] then x else lastElem xs
lastElem [] = '0'


findInList (x:xs) word = if (x == word) then True else findInList xs word
findInList [] word = False


findInList2 (x:xs) word = if (x== word) then True else findInList2 xs word
findInList2 [] word = False

-- scanWord (x:xs) = if (findInList keywords x) == True then ("keyword",)

-- tokenMaker (x:xs) = if (findInList operators x) == True then ("operator",x): tokenMaker xs else tokenMaker xs
-- tokenMaker [] = []



helper1 (x:xs:xss) list1 final= if (findInList operators x) == False && (findInList delimeters x) == False && x /= ' '
                                    then helper1 (xs:xss) (list1 ++ [x]) final 
                                else if x=='/' && xs == '/' then [x:xs:xss]
                                else if x == '/' && xs == '*' then [x:xs:xss] 
                                else if (lastElem (x:xs:xss) == '/') && (lastElem (listWithoutLast (x:xs:xss) (lengthOfList (x:xs:xss)))) == '*' then [x:xs:xss]
                                else if(findInList2 operators2 [x,xs]) == True 
                                    then helper1 xss ([]) (helper2 (helper2 final (list1)) ([x]++[xs]))
                                else if(findInList2 operators2 [x]) == True
                                    then helper1 (xs:xss) ([]) (helper2 (helper2 final (list1)) ([x]))
                                else if x == ' ' then helper1 (xs:xss) [] (helper2 (helper2 final (list1)) ([]))
                                else helper1 (xs:xss) ([]) (helper2 (helper2 final (list1)) [x])
helper1 (x:[]) list1 final = if (findInList operators x) == False && (findInList delimeters x) == False 
                                then helper1 [] (list1++[x]) final 
                                else helper1 [] ([]) (helper2 (helper2 final (list1)) [x])
helper1 [] list1 final = helper2 final list1

helper2 list a = list ++ [a]

-- wordsDividerHelper3 (x:xs) =if x == "" || x == " " then wordsDividerHelper3 xs else x : wordsDividerHelper3 xs 
-- wordsDividerHelper3 [] = []

checkComment list = if (lengthOfList list > 8) then 
                      if list!!1=='c' && list!!2 == 'o' && list!!3 == 'm' && list!!4 == 'm' && list!!5 == 'e' && list!!6 == 'n' && list!!7 == 't' then True else False
                      else False

checkMultiComment list = if (lengthOfList list > 10) then if list!!1 == 'm' && list!!2 == 'u' && list!!3 == 'l' && list!!4 == 't' && list!!5 == 'i' && list!!6 == 'l' && list!!7 == 'i' && list!!8 == 'n' && list!!9 == 'e' then True else False else False

-- wordsDividerHelper2 (x:xs) =  wordsDividerHelper3 x: wordsDividerHelper3 xs
-- wordsDividerHelper2 [] = []

wordsDivider words = helper1 words [] [] 


z = [["int"," ","xY",";",""],["xY","=","43",";",""]]
removeUn (x:xs) = removal x : removeUn xs
removeUn [] = []
removal (x:xs) = if x == "" || x == " " || x == [] then removal xs else x:removal xs
removal [] = []
-- removal (x:xs:xss) = removal2 (x:xs:xss)
-- removal [] = []    -- remove blank spaces etc 

final (x:xs) = removeUn (finalHelper (x:xs) [])

commentChecker word = if (tempBlankRemover word)!!0 == '/' && (tempBlankRemover word)!!1 == '/' then True else False

commentChecker3 word = if (tempBlankRemover word)!!0 == '/' && (tempBlankRemover word)!!1 == '*' then True else False


commentChecker2 word = if (lastElem (tempBlankRemover word)) == '/' && (secondLastElem (tempBlankRemover word)) == '*' then True else False


secondLastElem word = word!!((lengthOfList word)-2)


contains1 (x:xs:xss) =if xss /= [] then if x == '/' && xs == '/' then True else contains1 (xs:xss) else if x==xs then True else False
contains1 [] = False
contains1 [x] = False

doesNotContain1 list (x:xs:xss) = if x == '/' && xs == '/' then list else doesNotContain1 (list++[x]) (xs:xss)
doesNotContain1 list "" = ""
doesNotContain1 list (x:[]) = []

onlycontains1 (x:xs:xss) list = if x == '/' && xs == '/' then (x:xs:xss) else onlycontains1 (xs:xss) (xs:xss)
onlycontains1 (x:[]) list = []

contains2 (x:xs:xss) =if xss/=[] then if x == '/' && xs == '*' then True else contains2 (xs:xss) else if x=='/' && xs =='*' then True else False
contains2 [] = False
contains2 (x:[]) = False

doesNotContain2 list (x:xs:xss) = if list == [] && x == '/' && xs == '*' then [] else if x == '/' && xs == '*' then list else doesNotContain2 (list++[x]) (xs:xss)
doesNotContain2 list [] =list

onlycontains2 (x:xs:xss) list = if x == '/' && xs == '*' then (x:xs:xss) else onlycontains2 (xs:xss) (xs:xss)
onlycontains2 "" _ = ""


contains3 (x:xs:xss) = if xss /= [] then if x == '*' && xs == '/' then True else contains3 (xs:xss) else if x == '*' && xs =='/' then True else False
contains3 [] = False
contains3 (x:[]) = False

onlycontains3 list (x:xs:xss) = if xss /= [] then if x == '*' && xs == '/' then (list++[x]++[xs]) else onlycontains3 (list++[x]) (xs:xss) else (list++[x] ++[xs])
onlycontains3 list (x:[]) = []
onlycontains3 list "" = ""


doesNotContain3 (x:xs:xss) list = if xss /= [] then if x == '*' && xs == '/' then xss else doesNotContain3 (xs:xss) (xs:xss) else []
doesNotContain3 [] list = list
doesNotContain3 (x:[]) list= []



finalHelper (x:xs) list = if (tempBlankRemover x) == "" then finalHelper xs list
                    else if list/="" && contains2 list == True && contains3 list == True then [list]: finalHelper (x:xs) []
                    else if list/="" && contains2 list== True && contains3 list== False && contains3 x == False then finalHelper xs (list++"\n" ++ x)
                    else if list/="" && contains2 list== True && contains3 list== False && contains3 x == True then (wordsDivider (doesNotContain3 x [])): [list++"\n"++(onlycontains3 [] x)] : finalHelper xs []
                    else if contains1 x== True && x/= "" then wordsDivider (doesNotContain1 [] x): [(onlycontains1 x [])]: finalHelper (xs) list
                    else if x/= "" && contains2 x== True && contains3 x == False then (wordsDivider (doesNotContain2 [] x) : finalHelper xs (list ++ (onlycontains2 x []))) 
                    else if x/= "" && contains2 x== True && contains3 x== True then [x]: finalHelper (xs) []
                        else if wordsDivider (x) /= [] then wordsDivider (x):finalHelper xs []
                        else finalHelper xs list            
finalHelper [] list = if commentChecker2 list == True then [[list]] else []

jammer (x:xs) = x ++ jammer xs
jammer [] = []

func a b = a ++ b
extraHelper list = (wordsDivider (doesNotContain1 [] list)) ++ [(onlycontains1 list [])]

-- if commentChecker x== True then (x:xs) else 
--HELPER 1 and 2 WILL DIVIDE A STRING INTO DIFFERENT PARTS DEPENDING ON THE DELIMETERS AND OPERATORS 


tupleGenerator (x:xs) = tupleGeneratorHelper2 (commentParser (x)): tupleGenerator xs    --[[string]] / [[[char]]]
tupleGenerator [] = []

-- tupleGenerator (x:xs) = if ((tetraCommentParser x) == x) then (tupleGeneratorHelper2 (commentParser (x))) : tupleGenerator xs
--                         else tupleGenerator (tetraCommentParser2 (x:xs))


joincom m1 m2 = m1 ++ m2      


tetraCommentParser (x:xs) = if x!!0 == '/' && x!!1 =='*' 
                            then if (doesEndExist (x:xs) == True) then (x:xs) 
                            else ["False"]
                            else (x:xs)
tetraCommentParser [] = ["True"]

doesEndExist (x:xs) = if lastElem x == '/' && lastElem (listWithoutLast x (lengthOfList x)) == '*' 
                                then True
                                else doesEndExist xs
doesEndExist [] = False
-- checkMultiLine (x:xs) = --[string] 

-- checkMultiLine2

-- checkMultiLine3  

cRemover (x:xs) = if x == [] then cRemover xs else x:cRemover xs
cRemover [] = []

commentParser (x:xs) = if (lengthOfList (x)) > 1 then if (tempBlankRemover x)!!0 == '/' && (tempBlankRemover x)!!1 == '/' then commentParseHelper (x) : commentParser xs 
                        else if (tempBlankRemover x)!!0 == '/' && (tempBlankRemover x)!!1 == '*' && (lastElem (tempBlankRemover x)) == '/' && (secondLastNode (tempBlankRemover x)) =='*' then commentParseHelperMulti x : commentParser xs
                        else if (tempBlankRemover x)!!0 == '/' && (tempBlankRemover x)!!1 == '*'then (commentParseHelperMulti (checkEnd (x:xs) [])): (commentParser (checkEnd2 (x:xs)))
                        else x:commentParser xs
                        else x:commentParser xs
commentParser [] = [] -- [string]

removeInitialBlank (x:xs) = if x == ' ' then removeInitialBlank xs else (x:xs)

commentParseHelper (x:xs) =  ("<comment," ++ (removeInitialBlank (x:xs))  ++ "> ")
                                --single Line comment /string
commentParseHelper [] = ""

commentParseHelperMulti (x:xs) =  ("<multiline-comment," ++ (x:xs)  ++ "> ")
                                --multi Line comment /string
commentParseHelperMulti [] = ""

-- listWithoutSecond (x:xs:xss) = x:xss
-- listWithoutSecondLast length (x:xs) count = if (count == (length-2)) then listWithoutSecondLast length xs (count+1) else x:listWithoutSecondLast length xs (count+1)
-- listWithoutSecondLast length [] count = []
-- removeStars (x:xs) = listWithoutSecond (listWithoutSecondLast (lengthOfList (x:xs)) (x:xs) 0)

multiLines (x:xs) = x ++ "\n" ++ multiLines xs
multiLines [] = []

commentParseHelper2 (x:xs) = x ++ commentParseHelper2 xs
commentParseHelper2 [] = []

                                
-- commentParseHelper3 (x:xs) = commentParseHelper (x) : co                            

secondElem (x:xs:xss) = xs

checkEnd (x:xs) list1 = if lastElem x == '/' && lastElem (listWithoutLast x (lengthOfList x)) == '*' 
                                then (commentParseHelper2 (list1 ++ [x]))
                                else checkEnd xs (list1 ++ [x])

-- newLineBreak string = string ++ "!NEWLINEHERE!"

-- checkParserDuplicate (x:xs) = commentParseHelper (x) :checkParserDuplicate xs
-- checkParserDuplicate [] = []

checkEnd2 (x:xs) = if lastElem x /= '/' && lastElem (listWithoutLast x (lengthOfList x)) /= '*'
                            then checkEnd2 xs
                            else xs
checkEnd2 [] = []

listwithoutFirst (x:xs) = xs
listwithoutFirst [] = []

stringM (x:xs) = x ++ stringM xs
stringM [] = []
listwithoutFirst2 (x:xs:xss) = xss
listwithoutFirst2 (x:[]) = []
listwithoutFirst2 [] = []
listWithoutFirst2Helper (x:xs:xss) = xss

stringFinale list c = if c > 0 
                        then list!!0 ++ stringFinale (listwithoutFirst list) (c-1)
                        else []

removeSlash (x:xs:xss) = xss
removeSlash [] = []

tupleGeneratorHelper2 (x:xs) = if x /= [] then tupleGeneratorHelper x : tupleGeneratorHelper2 xs
                                else tupleGeneratorHelper2 xs
tupleGeneratorHelper2 [] = []


tempBlankRemover (x:xs) = if x == ' ' then tempBlankRemover xs else x: tempBlankRemover xs       
tempBlankRemover [] = []

findOperator (x:xs) word = if x == word then x else findOperator xs word
findOperator [] word = []

tupleGeneratorHelper (x:xs) = if (x:xs) == "" then ""
                              else if (checkComment (tempBlankRemover (x:xs)) == True) then (x:xs)
                              else if (checkMultiComment (tempBlankRemover (x:xs)) == True) then (x:xs)
                              else if (identifiers (tempBlankRemover (x:xs))) == True 
                                then ("<identifier," ++ (tempBlankRemover (x:xs)) ++ "> ")
                              else if (findInList delimeters x) == True 
                                then ("<delimiter,"++[x]++"> ")
                              else if (findInList operators2 (tempBlankRemover (x:xs))) == True
                                then ("<operator,"++(tempBlankRemover (x:xs))++"> ")
                              else if (findInList keywords (tempBlankRemover (x:xs))) == True
                                  then ("<keyword,"++(tempBlankRemover (x:xs))++"> ")
                              else if (checkInt (tempBlankRemover (x:xs)) True) == True
                                  then ("<intConstant,"++(tempBlankRemover (x:xs))++"> ")
                                else if (checkPrec (tempBlankRemover (x:xs)) True) == True
                                    then ("<floatConstant,"++(tempBlankRemover (x:xs))++"> ")
                                    else if (stringConstant (x:xs)) == True
                                     then ("<stringConstant,"++(x:xs) ++"> ")
                              else ("<error,"++(x:xs)++"> ")
                             
tupleGeneratorHelper [] = " "



dListConvertor (x:xs) = convertorHelper (x) : dListConvertor xs
dListConvertor [] = []

convertorHelper (x:xs) = x ++ convertorHelper xs
convertorHelper [] = []

-- sentenceGrabberHelper (x:xs) = if checkMultiComment (x) == True then 





sentenceGrabber (x:xs) =  x++ "\n" ++ sentenceGrabber xs
sentenceGrabber [] = []



